# GC  
## 垃圾回收算法  
* 引用计数法：为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的计数器为0，则说明该对象已经死亡，便可以回收了。具体实现：如果一个引用，被赋值为某一个对象，那么该对象的引用计数器+1，如果指向该对象的引用被赋给其他值，那么计数器-1；<font size='3' color='red'>注意：引用计数法无法处理循环引用对象，</font>举个例子：对象a,b相互引用，除此之外没有其他引用指向a,b，在这种情况下，a,b已经死亡，但由于他们的引用计数器都不为0，所以空间不可回收，<font size='3' color='red'>从而造成了内存泄漏</font>
* 可达性分析法：目前<font size='3' color='red'>java虚拟机采用的就是可达性分析法</font>。首先了解一下GC Roots   
 ![](https://github.com/FantasmYi/CodeMonkeyNote/blob/master/image/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png)      
 GC Roots可理解为用堆外指向堆内的引用，一般而言，GC Roots包括但不限于：          
  * java栈帧中的局部遍历
  * 已加载类的静态变量
  * JNI handles
  * 已启动且未停止的java线程              
此算法的实质在于将一系列GC Rootes作为初始的存活对象合集，然后从该集合出发，探索所有能够被该集合引用到的对象，并将其加入到集合中，这个过程称为标记。最终，未被探索到的对象就是死亡的，可被回收的。 
可达性算法可以解决引用计数法不能解决的循环引用问题。
  缺点：误报（将引用设置为null）,漏报（将引用设置为未被访问的对象而回收，严重）
* 复制算法：java中新生代的from和to空间就是使用这个算法。其核心思想是将内存分为2部分，每次只使用其中的一部分（假设A），在垃圾回收时，将正在使用的内存中的存留对象复制到没被使用的内存块中（假设B），之后清除A中的所有的对象，反复去交换两个内存的角色，完成垃圾收集。
* 标记清除法：就是分为标记和清除两个阶段进行处理内存中的对象，这种方式有很大弊端，就是空间碎片的问题，垃圾回收后的空间不是连续的，不连续的内存空间的工作效率要低于连续的内存空间。
* 标记压缩法：是标记清除法的升级，把存活的对象压缩到内存一段，而后进行垃圾清理。java中的老年代使用的就是标记压缩法。

## 垃圾回收的三种方式  
* 清除：把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表中，当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新的对象
  * 缺点： 
    1.会造成内存碎片。由于java虚拟机的堆中对象是连续分布的，因此可能出现总空间内存足够，但无法分配的极端情况。
    2.分配效率低。java虚拟机要逐个访问列表中的项来查找能够放入新建对象的空闲内存。
* 压缩：把存货对象聚集到内存的起始位置，从而留下一段连续的内存空间。这种做法解决内存碎片化的问题，代价是压缩算法的性能开销
* 复制： 把内存分为两个等分，分别用两个指针from和to来维护，并且只是用from指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到to指针指向的内存区域中，并且交换from指针和to指针的内容。此方法可解决碎片化问题。缺点：堆空间的使用效率低下。见下图
  ![](https://github.com/FantasmYi/CodeMonkeyNote/blob/master/image/FromAndTo.png)  
  
