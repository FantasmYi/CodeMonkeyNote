# GC  
## 垃圾回收算法  
* 引用计数法：为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的计数器为0，则说明该对象已经死亡，便可以回收了。具体实现：如果一个引用，被赋值为某一个对象，那么该对象的引用计数器+1，如果指向该对象的引用被赋给其他值，那么计数器-1；<font size='3' color='red'>注意：引用计数法无法处理循环引用对象，</font>举个例子：对象a,b相互引用，除此之外没有其他引用指向a,b，在这种情况下，a,b已经死亡，但由于他们的引用计数器都不为0，所以空间不可回收，<font size='3' color='red'>从而造成了内存泄漏</font>
* 复制算法：java中新生代的from和to空间就是使用这个算法。其核心思想是将内存分为2部分，每次只使用其中的一部分（假设A），在垃圾回收时，将正在使用的内存中的存留对象复制到没被使用的内存块中（假设B），之后清除A中的所有的对象，反复去交换两个内存的角色，完成垃圾收集。
* 标记清除法：就是分为标记和清除两个阶段进行处理内存中的对象，这种方式有很大弊端，就是空间碎片的问题，垃圾回收后的空间不是连续的，不连续的内存空间的工作效率要低于连续的内存空间。
* 标记压缩法：是标记清除法的升级，把存活的对象压缩到内存一段，而后进行垃圾清理。java中的老年代使用的就是标记压缩法。
* 可达性分析法：目前<font size='3' color='red'>java虚拟机采用的就是可达性分析法</font>。首先了解一下GC Roots   
 ![](https://github.com/FantasmYi/CodeMonkeyNote/blob/master/image/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png)      
 GC Roots可理解为用堆外指向堆内的引用，一般而言，GC Roots包括但不限于：          
  * java栈帧中的局部变量
  * 已加载类的静态变量
  * JNI handles
  * 已启动且未停止的java线程              
此算法的实质在于将一系列GC Rootes作为初始的存活对象合集，然后从该集合出发，探索所有能够被该集合引用到的对象，并将其加入到集合中，这个过程称为标记。最终，未被探索到的对象就是死亡的，可被回收的。 
可达性算法可以解决引用计数法不能解决的循环引用问题。
  产生的问题：老年代的对象可能引用新生代的对象，该引用也会被作为GC Roots。这意味着又要做一次全堆扫描
  缺点：误报（将引用设置为null）,漏报（将引用设置为未被访问的对象而回收，严重）
### 卡表
 * 为了避免全堆扫描问题，可以使用卡表技术。该技术将这个堆划分为一个个大小为512字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位，这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么认为这张卡是脏的
 * 在进行Minor GC时，我们可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到GC Roots中，当完成所有脏卡的扫描之后，java虚拟机会将所有脏卡的标识位清零
### 解决漏报问题（Stop-the-world）及安全点
 * Stop-the-world：通过安全点机制来实现。停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也造成了垃圾回收所谓的暂停时间。
 * 安全点：当虚拟机收到线程A的stop-the-world请求后，会等待所有的线程都到达安全点（一个稳定的执行状态，在这个执行状态下，虚拟机的堆栈不会发生变化），才允许线程A进行独占的工作。 

## 垃圾回收的三种方式  
* 清除：把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表中，当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新的对象
  * 缺点： 
    1.会造成内存碎片。由于java虚拟机的堆中对象是连续分布的，因此可能出现总空间内存足够，但无法分配的极端情况。
    2.分配效率低。java虚拟机要逐个访问列表中的项来查找能够放入新建对象的空闲内存。
* 压缩：把存货对象聚集到内存的起始位置，从而留下一段连续的内存空间。这种做法解决内存碎片化的问题，代价是压缩算法的性能开销
* 复制： 把内存分为两个等分，分别用两个指针from和to来维护，并且只是用from指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到to指针指向的内存区域中，并且交换from指针和to指针的内容。此方法可解决碎片化问题。缺点：堆空间的使用效率低下。见下图
  ![](https://github.com/FantasmYi/CodeMonkeyNote/blob/master/image/FromAndTo.png)  
  
 ## 总结 
 * java虚拟机中的垃圾回收器采用可达性分析来探索所有存活对象。他从一系列GC Roots出发，边标记边探索所有被引用的对象。
 * 整个新生代应用到了标记-复制算法，将S区中的老存活对象晋升到老年代，然后将剩下的存活对象和Eden区的存活对象复制到另一个S区中。
 * 为了防止在标记过程中堆栈的状态发生改变，java虚拟机采用安全点机制来实现Stop-the-world操作，暂停其他非垃圾回收线程。
 * 回收死亡对象的内存共有三种方式：
   * 会造成内存碎片的清除
   * 性能开销较大的压缩
   * 堆使用效率低的复制
  
