# redis的持久化机制  
持久化，即将数据保存到磁盘。redis以数据结构的形式将数据维持到内存中，为了让这些数据在redis重启后仍然可用，reids提供了AOF和RDB两种持久化模式。
redis提供了两种持久化机制：   
* AOF  追加，以协议文本的方式，将所有对数据库进行过写入命令（及其参数）记录到AOF文件，以此达到记录数据库状态的目的。    
* RDB  将数据库的快照以二进制的方式保存到磁盘中  

## AOF  
* 同步命令到AOF文件的整个过程可以分为三个阶段  
  * 命令传播  当一个redis客户端要执行命令时，它通过网络连接，将协议文本发送给redis服务器。服务器在接收到客户端请求后，会根据协议文本内容，选择适当的命令函数，将各个参数从字符串文本转换为redis字符串对象。当命令函数执行成功后，命令参数会传播到AOF程序。（redis将执行完的命令、命令的参数、命令的参数的个数等信息发送到AOF程序中）
  * 缓存追加  AOF程序根据接收到的命令数据，将命令格式转化为网络通讯协议（原来的协议文本）的格式，然后将协议内容追加到服务器的AOF缓存中（redisServer结构的aof_buf末尾）
  * 文件写入和保存  AOF缓存中的内容被写入到AOF文件末尾，如果设定的AOF保存条件被满足时，fsync函数或者fdatasync函数将写入的内容真正的保存到磁盘中。
  * write:根据条件，将aof_buf中的缓存写入到AOF文件
  * save：根据条件，调用fsync函数，将AOF文件保存到磁盘上
### AOF的三种保存模式
  * 不保存
  * 每秒钟保存一次
  * 没执行一个命令保存一次
### AOF的重写机制
  * 为了解决AOF文件体积急速膨胀问题，redis需要对aof文件进行重写。创建一个新的AOF文件代替原有的AOF文件，新老文件保存的数据库状态完全一致，但新文件体积小于老文件
  * 实现原理：根据键的类型，使用适当的写入命令来重现键的当前值
  * 为防止当前数据库的数据和重写后的AOF文件中数据不一致，redis增加了一个AOF重写缓存
  * 触发条件：可手动触发，默认情况下如果当前AOF文件大小比最后一次AOF文件重写时的大小要大一倍时，会自动触发AOF重写

## RDB  
* 在redis运行时，RDB程序将当前内存中的数据库快照保存到磁盘文件中，在redis重启动时，RDB程序可以通过载入RDB文件来还原数据库的状态。 
* redis功能最核心的rbdSave和rdbLoad两个函数，前者用于生成RDB文件到磁盘，后者用于将RDB文件中的数据重新载入到内存中。
### 保存
 * rdbSave负责将内存中的数据库数据以RDB的格式保存到磁盘中，如果RDB文件已经存在，那么新的RDB文件将替换已有的RDB文件。
 * 在保存RDB文件期间，主进程会被阻塞，知道保存完成为止  
 * SAVE和BGSAVE两个命令都会调用rdbSave函数，但调用方式不同
   * save直接调用rdbSave,阻塞主线程，知道保存完成为止。在主线程阻塞期间，服务器不能处理任何请求。 
   * BGSAVE则fork出一个子进程，子进程负责调用rdbSave,并在保存完成后向主线程发送信号，通知保存完成，因为是在子线程中调用的，所以主线程阻塞期间，服务器仍然可以处理请求。
 * RDB的文件结构 
   ![](https://github.com/FantasmYi/CodeMonkeyNote/blob/master/image/RDB.png)    
    * redis:文件最开始保存着redis的五个字符，标识着一个RDB文件的开始。作用：读入文件时，检查一个文件的前五个字节，判断该文件是否是RDB文件 
    * rdb-version:一个四字节长的以字符表示的整数，记录该文件所使用的RDB版本号
    * db-data:每个db-data部分保存着服务器上一个非空数据库的所有数据
    * select-db 保存	着跟在后面的键值所属的数据库号码。在读入RDB文件时，程序会根据这个域的值来切换数据库，确保数据被还原到正确的数据库
    * key-value-pairs 空的数据库不会被保存到RDB文件，所以这个部分至少包含一个键值对的数据
    * EOF 标志着数据库内容的结尾
    
  

  
