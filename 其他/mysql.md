## 索引
### 索引的类型  
 * 主键索引     
   在主键列上创建索引
 * 唯一索引      
   索引列上的值不允许重复，可以有NULL值
 * 普通索引  
   基本的索引类型，值可以重复，没有唯一性的限制 
 * 全文索引  
   可以在char,varchar,text的列上创建      
 #### 主键索引和唯一索引的区别：  
   主键创建后一定包含一个唯一索引，但唯一索引不一定是主键索引  
   主键列在创建时，已经默认为null+唯一索引  
   主键索引一张表只能有一个，唯一索引可以有多个
### 建立索引的优缺点及适合建立索引的字段
#### 优点：
 * 通过创建唯一性索引，可以保证数据表中每一行数据的唯一性
 * 加快数据的检索速度等     
#### 缺点：
 * 创建索引和维护所以要耗费时间，时间随数据量的增长而增加
 * 索引需要物理空间，除了数据表占占数据空间之外，每个索引还要占一定的物理空间，如果简历聚簇索引，那么需要的空间会更大。
 * 当对表中的数据进行增加，删除和修改的时候，索引也要动态维护，这样就降低了数据的维护速度。       
#### 适合建立索引的字段：
 * 经常用来查询的字段
 * 经常用到连接的列上加索引，这些列主要是外键，可以加快连接的速度
 * 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的。
 * 在经常需要排序的列上增加索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间
 * 在where子句的列上增加索引，加快条件的判断速度              
#### 不适合建立索引的字段：
  * 在查询中很少使用或者参考的列不应该创建索引
  * 对于只有很少数据值的列也不应该增加索引，例如性别（即需要在表中检索的数据行比例较大，增加索引，并不能加快索引速度）
  * 对于定义为txt、image类型的列不应该增加索引（因为这些数据量要么取值很小，要么数据量相当大）
  * 修改性能远大于检索性能时，不应该创建索引。修改性能和检索性能是矛盾的。    
  注意：索引可以提高select的效率，但同时也会降低insert和update的效率，因为insert和update有时可能会重建索引。     
## sql优化    
 1.对查询进行优化，应尽量避免全表扫描(很重要，常见count(*)、like)，首先考虑在where及order by涉及的列上建立索引。  
 2.避免在where子句中对字段进行Null值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：   
   select * from table where num=null   
   可以在num上设置默认值0，确保表中没有null值，然后这样查询：   
   select id from table where num=0
 3.避免在where子句中使用!=或<>操作符，否则引擎将放弃使用索引而进行全表扫描。  
 4.避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描（or可以换成union all）
 5.not in也要慎用，否则会导致全表扫描，对于连续的数值，能用between就不要用In
 6.避免在where子句中对字段进行表达式操作，浙江导致引擎放弃使用索引而进行全表扫描 
 7.在使用模糊查询（like）时要注意,通配符在后，走索引，通配符在前，全表查
### 其他优化  
1.尽可能使用varchar代替char，因为varchar存储空间小，对于查询来说，在一个相对较小的字段内搜索效率显然要高些。    
2.尽量不要使用*，不要反悔用不到的任何字段。
3.尽量使用数字型字段，因为引擎处理查询和连接时会逐个比较字符串的每一个字符，而数字比较一次就够了。
 
## mysql索引底层数据结构  
  首先了解一个概念：度。结点所拥有的子树的个数称为该结点的度，例如称度为2的树为2叉树     
  度的大小取决于节点内key和data的大小，度越大，树的性能越好     
### 选择b+树的原因：
  不用红黑树的原因：树的深度不可控。底层用B树实现，可以实现横向扩展，在内存中进行节点的横向查找，时间消耗可以忽略不计，
  mysql用b+树不用b树的原因：b+树度大。为了保证效率，尽可能把高度降低（h值小）。因为b+树去掉了data域，所以度大。缺点是会有冗余。
  Cpu->内存->磁盘，减少cpu和磁盘间的i/o交互，则可以提高效率。交互一次有大小限制。 假设cpu一次从磁盘上读取数据的大小为4k，那么将一个非叶子节点的大小设置为4k,可以大大提高效率。
  
## mysql的两个引擎
 注意：mysql的引擎是表级别，不是数据库级别   
### myisam(非聚集索引)
 索引文件和数据文件是分离的     
 mysql->data->employess 文件夹下使用myisam殷勤的几种文件类型：.fm是表结构存储文件 .MYD存储表结构 .MYI存储索引文件    
 ![](https://github.com/FantasmYi/CodeMonkeyNote/blob/master/image/myisam.png)   
 注意：叶子节点存储的是某一行记录的文件指针，不是data，这里和Innodb有区别    
 myisam的主键索引和非主键索引都是用b+树实现的，但是两个索引不在一棵树上。    
### innodb(聚集索引)
位置同上， .fm是表结构文件 .ibd是表索引+数据文件    
下图是主键索引    
![](https://github.com/FantasmYi/CodeMonkeyNote/blob/master/image/innodb.png)     
下图是非主键索引    
![](https://github.com/FantasmYi/CodeMonkeyNote/blob/master/image/innodb2.png)   
注意：innodb表必须有主键，否则会报错。推荐使用整形的自增主键，不要用uuid，uuid需要的存储空间大且用整形数据比较快，自增是因为没增加一个索引（例如id），叶子节点都会在最右边。索引字符串的比较用ascii码，非主键索引的data存储的是主键    
非主键索引之所以慢，是因为要通过两次b+树的查找，第一次在非辅助索引树上进行查找主键的操作，第二次根据查找到的主键到主键索引树上查找对应数据。      
